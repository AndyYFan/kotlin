/*
 * Copyright 2010-2015 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.jetbrains.kotlin.android.tests

import com.google.common.collect.Lists
import com.intellij.openapi.Disposable
import com.intellij.openapi.util.Disposer
import com.intellij.openapi.util.io.FileUtil
import com.intellij.openapi.util.io.FileUtilRt
import com.intellij.openapi.util.text.StringUtil
import org.jetbrains.kotlin.backend.common.output.OutputFileCollection
import org.jetbrains.kotlin.cli.common.output.outputUtils.writeAllTo
import org.jetbrains.kotlin.cli.jvm.compiler.EnvironmentConfigFiles
import org.jetbrains.kotlin.cli.jvm.compiler.KotlinCoreEnvironment
import org.jetbrains.kotlin.codegen.CodegenTestFiles
import org.jetbrains.kotlin.codegen.GenerationUtils
import org.jetbrains.kotlin.codegen.forTestCompile.ForTestCompileRuntime
import org.jetbrains.kotlin.codegen.state.GenerationState
import org.jetbrains.kotlin.config.CommonConfigurationKeys
import org.jetbrains.kotlin.config.JVMConfigurationKeys
import org.jetbrains.kotlin.idea.KotlinFileType
import org.jetbrains.kotlin.name.NameUtils
import org.jetbrains.kotlin.psi.KtFile
import org.jetbrains.kotlin.test.*
import org.jetbrains.kotlin.test.testFramework.KtUsefulTestCase
import org.jetbrains.kotlin.utils.Printer
import org.junit.Assert
import org.junit.Ignore
import java.io.File
import java.io.IOException
import java.util.*

@Ignore
class CodegenTestsOnAndroidGenerator private constructor(private val pathManager: PathManager) : KtUsefulTestCase() {
    private var WRITED_FILES_COUNT = 0

    private var MODULE_INDEX = 1

    private val generatedTestNames = Lists.newArrayList<String>()

    @Throws(Throwable::class)
    private fun generateOutputFiles() {
        prepareAndroidModule()
        generateAndSave()
    }

    @Throws(IOException::class)
    private fun prepareAndroidModule() {
        println("Copying kotlin-runtime.jar and kotlin-reflect.jar in android module...")
        copyKotlinRuntimeJars()

        println("Check \"libs\" folder in tested android module...")
        val libsFolderInTestedModule = File(pathManager.libsFolderInAndroidTestedModuleTmpFolder)
        if (!libsFolderInTestedModule.exists()) {
            libsFolderInTestedModule.mkdirs()
        }
    }

    @Throws(IOException::class)
    private fun copyKotlinRuntimeJars() {
        FileUtil.copy(
            ForTestCompileRuntime.runtimeJarForTests(),
            File(pathManager.libsFolderInAndroidTmpFolder + "/kotlin-runtime.jar")
        )
        FileUtil.copy(
            ForTestCompileRuntime.reflectJarForTests(),
            File(pathManager.libsFolderInAndroidTmpFolder + "/kotlin-reflect.jar")
        )

        FileUtil.copy(
            ForTestCompileRuntime.kotlinTestJarForTests(),
            File(pathManager.libsFolderInAndroidTmpFolder + "/kotlin-test.jar")
        )
    }

    @Throws(Throwable::class)
    private fun generateAndSave() {
        println("Generating test files...")
        val out = StringBuilder()
        val p = Printer(out)

        p.print(FileUtil.loadFile(File("license/LICENSE.txt")))
        p.println("package $testClassPackage;")
        p.println()
        p.println("import ", baseTestClassPackage, ".", baseTestClassName, ";")
        p.println()
        p.println("/* This class is generated by $generatorName. DO NOT MODIFY MANUALLY */")
        p.println("public class ", testClassName, " extends ", baseTestClassName, " {")
        p.pushIndent()

        generateTestMethodsForDirectories(p, File("compiler/testData/codegen/box"), File("compiler/testData/codegen/boxInline"))

        p.popIndent()
        p.println("}")

        val testSourceFilePath =
            pathManager.srcFolderInAndroidTmpFolder + "/" + testClassPackage.replace(".", "/") + "/" + testClassName + ".java"
        FileUtil.writeToFile(File(testSourceFilePath), out.toString())
    }

    @Throws(IOException::class)
    private fun generateTestMethodsForDirectories(p: Printer, vararg dirs: File) {
        val holderMock = FilesWriter(false, false)
        val holderFull = FilesWriter(true, false)
        val holderInheritMFP = FilesWriter(true, true)

        for (dir in dirs) {
            val files = dir.listFiles()
            Assert.assertNotNull("Folder with testData is empty: " + dir.absolutePath, files)
            processFiles(p, files!!, holderFull, holderMock, holderInheritMFP)
        }

        holderFull.writeFilesOnDisk()
        holderMock.writeFilesOnDisk()
        holderInheritMFP.writeFilesOnDisk()
    }

    internal inner class FilesWriter constructor(
        private val isFullJdkAndRuntime: Boolean,
        private val inheritMultifileParts: Boolean
    ) {

        var files: MutableList<KtFile> = ArrayList()
        private var environment: KotlinCoreEnvironment? = null
        private var disposable: Disposable? = null

        init {
            this.disposable = TestDisposable()
            this.environment = createEnvironment(isFullJdkAndRuntime, disposable!!)
        }

        private fun createEnvironment(isFullJdkAndRuntime: Boolean, disposable: Disposable): KotlinCoreEnvironment {
            val configurationKind = if (isFullJdkAndRuntime) ConfigurationKind.ALL else ConfigurationKind.NO_KOTLIN_REFLECT
            val testJdkKind = if (isFullJdkAndRuntime) TestJdkKind.FULL_JDK else TestJdkKind.MOCK_JDK
            val configuration = KotlinTestUtils.newConfiguration(configurationKind, testJdkKind, KotlinTestUtils.getAnnotationsJar())
            configuration.put(CommonConfigurationKeys.MODULE_NAME, "android-module-" + MODULE_INDEX++)
            if (inheritMultifileParts) {
                configuration.put(JVMConfigurationKeys.INHERIT_MULTIFILE_PARTS, true)
            }
            return KotlinCoreEnvironment.createForTests(disposable, configuration, EnvironmentConfigFiles.JVM_CONFIG_FILES)
        }

        fun shouldWriteFilesOnDisk(): Boolean {
            return files.size > 300
        }

        fun writeFilesOnDiskIfNeeded() {
            if (shouldWriteFilesOnDisk()) {
                writeFilesOnDisk()
            }
        }

        fun writeFilesOnDisk() {
            writeFiles(files)
            files = ArrayList()
            if (disposable != null) {
                Disposer.dispose(disposable!!)
                disposable = TestDisposable()
            }
            environment = createEnvironment(isFullJdkAndRuntime, disposable!!)
        }

        fun addFile(name: String, content: String) {
            try {
                files.add(CodegenTestFiles.create(name, content, environment!!.project).psiFile)
            } catch (e: Throwable) {
                throw RuntimeException("Problem during creating file $name: \n$content", e)
            }

        }

        private fun writeFiles(filesToCompile: List<KtFile>) {
            if (filesToCompile.isEmpty()) return

            //1000 files per folder, each folder would be jared by build.gradle script
            // We can't create one big jar with all test cause dex has problem with memory on teamcity
            WRITED_FILES_COUNT += filesToCompile.size
            val outputDir = File(pathManager.getOutputForCompiledFiles(WRITED_FILES_COUNT / 1000))

            println(
                "Generating " + filesToCompile.size + " files" +
                        (if (inheritMultifileParts)
                            " (JVM.INHERIT_MULTIFILE_PARTS)"
                        else if (isFullJdkAndRuntime) " (full jdk and runtime)" else "") + " into " + outputDir.name + "..."
            )
            val outputFiles: OutputFileCollection
            var state: GenerationState? = null
            try {
                state = GenerationUtils.compileFiles(filesToCompile, environment!!)
                outputFiles = state.factory
            } catch (e: Throwable) {
                throw RuntimeException(e)
            } finally {
                if (state != null) {
                    state.destroy()
                }
            }

            if (!outputDir.exists()) {
                outputDir.mkdirs()
            }
            Assert.assertTrue("Cannot create directory for compiled files", outputDir.exists())

            outputFiles.writeAllTo(outputDir)
        }
    }

    @Throws(IOException::class)
    private fun processFiles(
        printer: Printer,
        files: Array<File>,
        holderFull: FilesWriter,
        holderMock: FilesWriter,
        holderInheritMFP: FilesWriter
    ) {
        holderFull.writeFilesOnDiskIfNeeded()
        holderMock.writeFilesOnDiskIfNeeded()
        holderInheritMFP.writeFilesOnDiskIfNeeded()

        for (file in files) {
            if (SpecialFiles.getExcludedFiles().contains(file.name)) {
                continue
            }
            if (file.isDirectory) {
                val listFiles = file.listFiles()
                if (listFiles != null) {
                    processFiles(printer, listFiles, holderFull, holderMock, holderInheritMFP)
                }
            } else if (FileUtilRt.getExtension(file.name) != KotlinFileType.INSTANCE.defaultExtension) {
                // skip non kotlin files
            } else {
                val fullFileText = FileUtil.loadFile(file, true)

                if (!InTextDirectivesUtils.isPassingTarget(TargetBackend.JVM, file)) {
                    continue
                }

                //TODO: support LANGUAGE_VERSION
                if (InTextDirectivesUtils.isDirectiveDefined(fullFileText, "LANGUAGE_VERSION:")) {
                    continue
                }

                //TODO: support multifile facades
                //TODO: support multifile facades hierarchies
                if (hasBoxMethod(fullFileText)) {
                    var filesHolder = if (InTextDirectivesUtils.isDirectiveDefined(fullFileText, "FULL_JDK") ||
                        InTextDirectivesUtils.isDirectiveDefined(fullFileText, "WITH_RUNTIME") ||
                        InTextDirectivesUtils.isDirectiveDefined(fullFileText, "WITH_REFLECT"))
                        holderFull
                    else
                        holderMock
                    filesHolder = if (fullFileText.contains("+JVM.INHERIT_MULTIFILE_PARTS")) holderInheritMFP else filesHolder

                    val classWithBoxMethod = genFiles(file, fullFileText, filesHolder) ?: continue

                    val generatedTestName = generateTestName(file.name)
                    generateTestMethod(
                        printer,
                        generatedTestName,
                        classWithBoxMethod.asString(),
                        StringUtil.escapeStringCharacters(file.path)
                    )
                }
            }
        }
    }

    private fun generateTestName(fileName: String): String {
        var result = NameUtils.sanitizeAsJavaIdentifier(FileUtil.getNameWithoutExtension(StringUtil.capitalize(fileName)))

        var i = 0
        while (generatedTestNames.contains(result)) {
            result += "_" + i++
        }
        generatedTestNames.add(result)
        return result
    }

    companion object {
        private const val testClassPackage = "org.jetbrains.kotlin.android.tests"
        private const val testClassName = "CodegenTestCaseOnAndroid"
        private const val baseTestClassPackage = "org.jetbrains.kotlin.android.tests"
        private const val baseTestClassName = "AbstractCodegenTestCaseOnAndroid"
        private const val generatorName = "CodegenTestsOnAndroidGenerator"


        @JvmStatic
        @Throws(Throwable::class)
        fun generate(pathManager: PathManager) {
            CodegenTestsOnAndroidGenerator(pathManager).generateOutputFiles()
        }


        private fun hasBoxMethod(text: String): Boolean {
            return text.contains("fun box()")
        }

        private fun generateTestMethod(p: Printer, testName: String, className: String, filePath: String) {
            p.println("public void test$testName() throws Exception {")
            p.pushIndent()
            p.println("invokeBoxMethod($className.class, \"$filePath\", \"OK\");")
            p.popIndent()
            p.println("}")
            p.println()
        }
    }
}
